---
title: "并发中的一些概念"
discriptions: "并发中的一些概念"
date: 2018-12-20T22:03:05+08:00
author: Pismery Liu
archives: "2018"
tags: [concurrent,Java]
categories: [Java]
showtoc: true
---
<!--more-->


# 并发基本概念

## CAS(Compare And Swap)

CAS机制有3个基本操作数:内存地址V，旧的预期值A，准备更新的新值B；

操作基本原理：若内存地址V当前实际的值等于预期值A，将内存地址V的值更新为B；若内存地址V当前实际的值不等于预期值A，则重新获取内存地址V当前实际值，重新操作后再尝试更新，这个获取值重新操作称为自旋；

CAS 缺陷:

- 若在并发量很高的情况下，多个线程反复尝试更新一个变量，却一直更新不成功，循环反复，容易给CPU带来很大的压力；
- CAS机制只能保证一个变量的原子操作，不能保证整个代码快的原子性。若想保证3个变量共同进行原子性更新，则不得不使用synchronized
- CAS最大的问题ABA问题 -> 解决办法:加入版本号


## 核心理论

### 共享性

共享性指资源对多个线程操作同一份资源，是导致线程不安全的主要前提之一。若所有线程都只操作线程内的数据，则就不会产生线程安全问题。这也是为什么编程过程中更倾向于编写无状态的类、方法。但是在多线程编程中，总不可避免需要数据共享。最明显的例子就是数据库访问，为了保证数据一致性，不可避免的需要多个线程访问同一数据，再通过锁机制保证线程的安全。

### 互斥性

互斥性指同一时刻只允许一个线程访问共享资源。通常我们允许多个线程同时读，但同一时刻允许一个线程写，此时读也是不允许的。这就是通常讲的共享锁(读锁)和排它锁(写锁)。在多线程环境中，如果所有线程只读共享资源，不修改共享资源，此时线程也是安全的，当需要复写共享资源时，就需要使用互斥操作来保证线程安全。所以在编写代码时，共享变量总是优先使用静态常量类型，迫不得已才通过互斥操作保证线程安全。在Java中最简单方便的就是使用synchronized关键字实现互斥性。

### 原子性

原子性指一个操作是一个独立的，不可分割的整体。原子性操作就是指一个连续不可中断的操作。最简单的原子操作就是系统指令，若一个操作对应一条系统指令就可以保证原子性。然而，许多操作都需要多个系统指令组合而成。例如:自增(i++)操作，需要以下三个步骤：

1. 获取i的值；
2. 对i进行运算+1操作；
3. 将结果写回主存中；

这就是为什么volatile只保证可见性和有序性，不保证原子性会导致i++操作仍然不安全。

### 可见性

要理解可见性，首先要了解JMM（Java内存模型），JMM与操作系统模型相似，如下图所示

![](https://raw.githubusercontent.com/Pismery/Picture/master/img20181219204949.png)


每个共享变量都存在主存中，当一个线程访问共享变量时，会将主存中的共享变量复制一份到自己的工作内存，只有线程对共享变量修改后，才会将工作内存的值更新到主存中。这就可能导致一个线程已经修改了数据，而另一个线程依旧拿着旧的数据做操作。这就是不可见性。而volatile实现了可见性就是通过线程每次读取共享资源都从主存读取，这就保证了一个线程对共享资源修改更新至主存，立刻能够被其他线程感知。同样synchronized也保证了可见性。

注意指令重排序也会导致不可见，而voatile关键字底层通过内存屏障实现了防重排序，这使得volatile关键字保证可见性。

### 有序性

这里有序性指避免指令重排序导致的线程不安全问题。下面重点介绍什么是指令重排序。

指令重排序是编译器和处理器为了优化程序对指令序列的重新排序，也就是说指令重排序目的是为了提高程序运行性能。

重排序有三类：

- 编译器优化重排序：编译器在不改变单线程运行程序结果的前提下，对执行语句的重新排序。
- 指令级并行重排序：由于现代处理器采用指令级并行技术(ILP)将多条指令并行执行。所以当两个操作之间不存在数据依赖，处理器可以改变语句对应的机器指令的执行顺序
- 内存系统重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

数据依赖：如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。数据依赖分为以下三种类型

有关指令重排序的内容详细请看JVM章节的指令重排序笔记。


## 线程状态

- 新建状态(New)：新创建了一个线程对象。
- 就绪状态(Runnable)：线程对象创建后，其他线程调用了该对象的start()方法。该状态的线程位于“可运行线程池”中，变得可运行，只等待获取CPU的使用权。即在就绪状态的进程除CPU之外，其它的运行所需资源都已全部获得。
- 运行状态(Running)：就绪状态的线程获取了CPU，执行程序代码。
- 阻塞状态(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。
阻塞的情况分三种：
    - 等待阻塞：运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒，
    - 同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。
    - 其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。
- 死亡状态(Dead)：线程执行完了或者因异常退出了run()方法，该线程结束生命周期

![](https://raw.githubusercontent.com/Pismery/Picture/master/img20181219215413.png)

## 锁

### 偏向锁、轻量级锁

引入偏向锁和轻量级锁目的都是为了当没有多线程竞争或者竞争不激烈的情况下，减少传统的重量级锁使用操作系统的互斥量（即Monitor）导致的性能消耗。轻量级锁通过CAS操作避免使用互斥量。而偏向锁则在无线程竞争的情况下整个同步都取消了。

Java6后默认启用偏向锁，若程序确认存在大量锁对象，并且都是高度并发情况，可以禁用偏向锁来提升性能

```
## 关闭偏向锁
-XX:-UseBiasedLocking   (注意是-号)

## 开启偏向锁
-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0  (注意+号，BiasedLockingStartupDelay因为默认是系统启动后延迟一段时间再开启偏向锁，所以配置成立即启用)
```

### 自旋锁

自旋锁是采用让当前线程不停地的在循环体内执行实现的，当循环的条件被其他线程改变时 才能进入临界区。

与互斥锁相似，基本作用是用于线程（进程）之间的同步。与普通锁不同的是，一个线程A在获得普通锁后，如果再有线程B试图获取锁，那么这个线程B将会挂起（阻塞）；试想下，如果两个线程资源竞争不是特别激烈，而处理器阻塞一个线程引起的线程上下文的切换的代价高于等待资源的代价的时候（锁的已保持者保持锁时间比较短），那么线程B可以不放弃CPU时间片，而是在“原地”忙等，直到锁的持有者释放了该锁，这就是自旋锁的原理，可见自旋锁是一种非阻塞锁。

### ReentrantLock：公平锁、非公平锁

公平锁：进入先检测等待队列是否有等待线程，若没有或者是第一个则获取锁，否则在队列中排队FIFO

非公平锁：进入直接获取锁，获取失败了才加入等待队列排队。

### 可重入锁

可重入锁指的是可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提得是同一个对象或者class），这样的锁就叫做可重入锁。ReentrantLock和synchronized都是可重入锁

> 参考链接

- [由Java引起的指令重排序思考](https://blog.csdn.net/qq_32646795/article/details/78221064)
- https://yq.aliyun.com/articles/348581
- http://www.cnblogs.com/paddix/p/5374810.html
- http://www.cnblogs.com/wewill/p/8086375.html


